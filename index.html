<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Neon Survivor</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- React & ReactDOM -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  
  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #1a1a1a;
      touch-action: none; /* Prevent pull-to-refresh on mobile */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      user-select: none;
      -webkit-user-select: none;
    }
    canvas {
      display: block;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: scale(0.95); }
      to { opacity: 1; transform: scale(1); }
    }
    .animate-fadeIn {
      animation: fadeIn 0.2s ease-out forwards;
    }
    /* Custom Scrollbar for upgrade list */
    ::-webkit-scrollbar {
      width: 8px;
    }
    ::-webkit-scrollbar-track {
      background: #1f2937; 
    }
    ::-webkit-scrollbar-thumb {
      background: #4b5563; 
      border-radius: 4px;
    }
    ::-webkit-scrollbar-thumb:hover {
      background: #6b7280; 
    }
  </style>
<script type="importmap">
{
  "imports": {
    "react-dom/": "https://aistudiocdn.com/react-dom@^19.2.0/",
    "react": "https://aistudiocdn.com/react@^19.2.0",
    "react/": "https://aistudiocdn.com/react@^19.2.0/"
  }
}
</script>
</head>
<body>
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // ==========================================
    // CONSTANTS & CONFIGURATION
    // ==========================================
    const WORLD_SIZE = 4000;
    const PLAYER_BASE_SPEED = 3.5;
    const FPS = 60;

    const COLORS = {
      player: '#3b82f6', // Blue
      enemyBasic: '#ef4444', // Red
      enemyFast: '#f97316', // Orange
      enemyTank: '#7f1d1d', // Dark Red
      enemySwarm: '#a855f7', // Purple
      enemyShooter: '#14b8a6', // Teal
      enemyBoss: '#be123c', // Rose (Big)
      gem1: '#10b981', // Green
      gem10: '#3b82f6', // Blue
      gem50: '#f59e0b', // Gold
      gemChest: '#fbbf24', // Gold Chest
      gemHealth: '#ec4899', // Pink
      projectile: '#e2e8f0',
      projectileEnemy: '#ef4444',
      textDamage: '#ffffff',
      textCrit: '#fbbf24',
    };

    // Waves configuration (Time in seconds)
    const WAVES = [
      { startTime: 0, spawnRate: 60, enemyTypes: ['basic'] },
      { startTime: 30, spawnRate: 45, enemyTypes: ['basic', 'fast'] },
      { startTime: 60, spawnRate: 30, enemyTypes: ['basic', 'fast', 'swarm'] },
      { startTime: 120, spawnRate: 20, enemyTypes: ['basic', 'tank', 'shooter'] },
      { startTime: 180, spawnRate: 15, enemyTypes: ['swarm', 'fast', 'tank'] },
      { startTime: 240, spawnRate: 100, enemyTypes: [], boss: true }, // Boss Spawn
      { startTime: 245, spawnRate: 10, enemyTypes: ['basic', 'swarm', 'shooter'] }, // Chaos after boss
    ];

    const BASE_WEAPONS = {
      kunai: {
        type: 'kunai',
        level: 1,
        cooldown: 40,
        cooldownTimer: 0,
        damage: 15,
        projectileSpeed: 12,
        range: 600,
      },
      orb: {
        type: 'orb',
        level: 0,
        cooldown: 0,
        cooldownTimer: 0,
        damage: 8,
        projectileCount: 0,
        range: 70,
      },
      aura: {
        type: 'aura',
        level: 0,
        cooldown: 30,
        cooldownTimer: 0,
        damage: 3,
        range: 120,
      },
      drill: {
        type: 'drill',
        level: 0,
        cooldown: 90,
        cooldownTimer: 0,
        damage: 20,
        projectileSpeed: 15,
        duration: 120,
        range: 1000,
      },
      brick: {
        type: 'brick',
        level: 0,
        cooldown: 50,
        cooldownTimer: 0,
        damage: 30,
        projectileSpeed: 0,
        duration: 60,
        range: 200,
      },
      lightning: {
        type: 'lightning',
        level: 0,
        cooldown: 80,
        cooldownTimer: 0,
        damage: 40,
        range: 500,
      }
    };

    const UPGRADES_POOL = [
      // --- Weapons ---
      {
        id: 'kunai_upgrade',
        name: 'ì¿ ë‚˜ì´',
        description: 'ê°€ì¥ ê°€ê¹Œìš´ ì ì—ê²Œ ìˆ˜ë¦¬ê²€ì„ ë˜ì§‘ë‹ˆë‹¤.',
        type: 'weapon',
        weaponType: 'kunai',
        icon: 'ğŸ—¡ï¸',
        rarity: 'common',
      },
      {
        id: 'orb_unlock',
        name: 'ìˆ˜í˜¸ì',
        description: 'ìºë¦­í„° ì£¼ë³€ì„ ë„ëŠ” ë³´í˜¸ë§‰ì„ ìƒì„±í•©ë‹ˆë‹¤.',
        type: 'weapon',
        weaponType: 'orb',
        icon: 'ğŸ”®',
        rarity: 'rare',
      },
      {
        id: 'aura_unlock',
        name: 'ì—­ì¥',
        description: 'ì£¼ë³€ ì ì—ê²Œ ì§€ì†ì ì¸ í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.',
        type: 'weapon',
        weaponType: 'aura',
        icon: 'ğŸ¤¢',
        rarity: 'common',
      },
      {
        id: 'drill_unlock',
        name: 'í™”ì‚´ ë“œë¦´',
        description: 'ì ì„ ê´€í†µí•˜ë©° ë‚ ì•„ê°€ëŠ” ë“œë¦´ì„ ë°œì‚¬í•©ë‹ˆë‹¤.',
        type: 'weapon',
        weaponType: 'drill',
        icon: 'ğŸ¹',
        rarity: 'rare',
      },
      {
        id: 'brick_unlock',
        name: 'ë²½ëŒ',
        description: 'ìœ„ë¡œ ë˜ì ¸ì ¸ ì•„ë˜ë¡œ ë–¨ì–´ì§€ë©° í° í”¼í•´ë¥¼ ì¤ë‹ˆë‹¤.',
        type: 'weapon',
        weaponType: 'brick',
        icon: 'ğŸ§±',
        rarity: 'common',
      },
      {
        id: 'lightning_unlock',
        name: 'ë²ˆê°œ ë°œì‚¬ê¸°',
        description: 'ë¬´ì‘ìœ„ ì ì—ê²Œ ë²¼ë½ì„ ë–¨ì–´ëœ¨ë¦½ë‹ˆë‹¤.',
        type: 'weapon',
        weaponType: 'lightning',
        icon: 'âš¡',
        rarity: 'epic',
      },
      // --- Stats ---
      {
        id: 'speed_boost',
        name: 'ìš´ë™í™”',
        description: 'ì´ë™ ì†ë„ê°€ 10% ì¦ê°€í•©ë‹ˆë‹¤.',
        type: 'stat',
        statType: 'speed',
        icon: 'ğŸ‘Ÿ',
        rarity: 'common',
      },
      {
        id: 'hp_boost',
        name: 'ë¡œë‹Œ ê°‘ì˜·',
        description: 'ìµœëŒ€ ì²´ë ¥ì´ 20% ì¦ê°€í•©ë‹ˆë‹¤.',
        type: 'stat',
        statType: 'maxHp',
        icon: 'ğŸ›¡ï¸',
        rarity: 'common',
      },
      {
        id: 'magnet_boost',
        name: 'ìì„',
        description: 'ì•„ì´í…œ íšë“ ë²”ìœ„ê°€ 25% ì¦ê°€í•©ë‹ˆë‹¤.',
        type: 'stat',
        statType: 'pickupRange',
        icon: 'ğŸ§²',
        rarity: 'common',
      },
      {
        id: 'cooldown_boost',
        name: 'ì—ë„ˆì§€ íë¸Œ',
        description: 'ê³µê²© ì¿¨íƒ€ì„ì´ 10% ê°ì†Œí•©ë‹ˆë‹¤.',
        type: 'stat',
        statType: 'cooldown',
        icon: 'ğŸ§Š',
        rarity: 'rare',
      },
      {
        id: 'power_boost',
        name: 'ê°•ë ¥í•œ ì´ì•Œ',
        description: 'ê³µê²©ë ¥ì´ 15% ì¦ê°€í•©ë‹ˆë‹¤.',
        type: 'stat',
        statType: 'power',
        icon: 'ğŸ’ª',
        rarity: 'rare',
      },
      {
        id: 'heal_potion',
        name: 'ê³ ê¸°',
        description: 'ì²´ë ¥ì„ 30% íšŒë³µí•©ë‹ˆë‹¤.',
        type: 'stat',
        statType: 'maxHp', 
        icon: 'ğŸ–',
        rarity: 'common',
      },
    ];

    // ==========================================
    // UTILS
    // ==========================================
    const distSq = (a, b) => (a.x - b.x) ** 2 + (a.y - b.y) ** 2;

    // ==========================================
    // COMPONENT: VIRTUAL JOYSTICK
    // ==========================================
    const VirtualJoystick = ({ onMove }) => {
      const containerRef = useRef(null);
      const [active, setActive] = useState(false);
      const [position, setPosition] = useState({ x: 0, y: 0 });
      const [origin, setOrigin] = useState({ x: 0, y: 0 });
      const maxRadius = 50;

      const handleStart = (clientX, clientY) => {
        setActive(true);
        setOrigin({ x: clientX, y: clientY });
        setPosition({ x: 0, y: 0 });
        onMove(0, 0);
      };

      const handleMove = (clientX, clientY) => {
        if (!active) return;
        const dx = clientX - origin.x;
        const dy = clientY - origin.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx);
        let stickX = dx;
        let stickY = dy;
        if (distance > maxRadius) {
          stickX = Math.cos(angle) * maxRadius;
          stickY = Math.sin(angle) * maxRadius;
        }
        setPosition({ x: stickX, y: stickY });
        onMove(stickX / maxRadius, stickY / maxRadius);
      };

      const handleEnd = () => {
        setActive(false);
        setPosition({ x: 0, y: 0 });
        onMove(0, 0);
      };

      useEffect(() => {
        const container = containerRef.current;
        if (!container) return;
        const onTouchStart = (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          handleStart(touch.clientX, touch.clientY);
        };
        const onTouchMove = (e) => {
          e.preventDefault();
          const touch = e.touches[0];
          handleMove(touch.clientX, touch.clientY);
        };
        const onTouchEnd = (e) => {
          e.preventDefault();
          handleEnd();
        };
        container.addEventListener('touchstart', onTouchStart, { passive: false });
        window.addEventListener('touchmove', onTouchMove, { passive: false });
        window.addEventListener('touchend', onTouchEnd);
        return () => {
          container.removeEventListener('touchstart', onTouchStart);
          window.removeEventListener('touchmove', onTouchMove);
          window.removeEventListener('touchend', onTouchEnd);
        };
      }, [active, origin]);

      const onMouseDown = (e) => handleStart(e.clientX, e.clientY);
      const onMouseMove = (e) => { if(active) handleMove(e.clientX, e.clientY); };
      const onMouseUp = () => { if(active) handleEnd(); };

      return (
        <div 
          ref={containerRef}
          className="absolute inset-0 z-10 w-full h-full select-none"
          onMouseDown={onMouseDown}
          onMouseMove={onMouseMove}
          onMouseUp={onMouseUp}
          onMouseLeave={onMouseUp}
        >
          {active && (
            <div 
              className="absolute w-32 h-32 rounded-full bg-white/10 border-2 border-white/20 backdrop-blur-sm pointer-events-none transform -translate-x-1/2 -translate-y-1/2 transition-opacity duration-75"
              style={{ left: origin.x, top: origin.y }}
            >
              <div 
                className="absolute w-12 h-12 rounded-full bg-white/50 shadow-lg top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2"
                style={{ 
                  transform: `translate(calc(-50% + ${position.x}px), calc(-50% + ${position.y}px))` 
                }}
              />
            </div>
          )}
        </div>
      );
    };

    // ==========================================
    // COMPONENT: HUD
    // ==========================================
    const HUD = ({ player, time, kills }) => {
      const formatTime = (frames) => {
        const seconds = Math.floor(frames / 60);
        const m = Math.floor(seconds / 60);
        const s = seconds % 60;
        return `${m}:${s.toString().padStart(2, '0')}`;
      };
      const xpPercentage = Math.min(100, (player.xp / player.nextLevelXp) * 100);

      return (
        <div className="absolute inset-0 pointer-events-none z-20 flex flex-col justify-between p-4">
          <div className="flex flex-col w-full gap-3">
            <div className="w-full h-8 bg-gray-900/80 border-2 border-gray-600 rounded-full overflow-hidden relative shadow-lg">
              <div 
                className="h-full bg-gradient-to-r from-green-500 to-emerald-400 transition-all duration-300 ease-out"
                style={{ width: `${xpPercentage}%` }}
              />
              <div className="absolute inset-0 flex items-center justify-center text-sm font-black text-white shadow-black drop-shadow-md">
                LV {player.level}
              </div>
            </div>

            <div className="flex justify-center items-center gap-8 text-white font-mono text-xl font-bold drop-shadow-lg bg-black/20 py-2 rounded-lg backdrop-blur-sm">
               <div className="flex items-center gap-2 text-yellow-300">
                 <span>â±ï¸</span>
                 <span>{formatTime(time)}</span>
               </div>
               <div className="flex items-center gap-2 text-red-400">
                 <span>ğŸ’€</span>
                 <span>{kills}</span>
               </div>
            </div>
          </div>
        </div>
      );
    };

    // ==========================================
    // COMPONENT: UPGRADE MODAL
    // ==========================================
    const UpgradeModal = ({ options, onSelect }) => {
      return (
        <div className="absolute inset-0 z-50 flex items-center justify-center bg-black/70 backdrop-blur-sm animate-fadeIn">
          <div className="bg-gray-800 border-4 border-yellow-500 rounded-xl p-6 max-w-4xl w-full mx-4 shadow-2xl">
            <h2 className="text-4xl font-black text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-yellow-200 text-center mb-2 drop-shadow-sm">ë ˆë²¨ ì—…!</h2>
            <p className="text-gray-300 text-center mb-8 text-lg">ëŠ¥ë ¥ì„ ì„ íƒí•˜ì„¸ìš”</p>
            
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              {options.map((opt, idx) => (
                <button
                  key={idx}
                  onClick={() => onSelect(opt)}
                  className="group relative flex flex-col items-center p-6 bg-gray-700/80 hover:bg-gray-600 border-2 border-gray-600 hover:border-yellow-400 rounded-xl transition-all transform hover:-translate-y-2 shadow-lg"
                >
                  <div className="text-7xl mb-6 group-hover:scale-110 transition-transform duration-200 filter drop-shadow-lg">
                    {opt.icon}
                  </div>
                  <h3 className="text-2xl font-bold text-white mb-2">{opt.name}</h3>
                  <div className="text-sm text-gray-300 text-center h-12 leading-snug">
                    {opt.description}
                  </div>
                  <div className={`mt-6 px-4 py-1 rounded-full text-xs font-black uppercase tracking-wide border
                    ${opt.rarity === 'common' ? 'bg-gray-600 border-gray-400 text-gray-200' : ''}
                    ${opt.rarity === 'rare' ? 'bg-blue-600 border-blue-400 text-white' : ''}
                    ${opt.rarity === 'epic' ? 'bg-purple-600 border-purple-400 text-white' : ''}
                  `}>
                    {opt.rarity === 'common' ? 'ì¼ë°˜' : opt.rarity === 'rare' ? 'í¬ê·€' : 'ì—í”½'}
                  </div>
                </button>
              ))}
            </div>
          </div>
        </div>
      );
    };

    // ==========================================
    // COMPONENT: MAIN MENU
    // ==========================================
    const MainMenu = ({ onStart, score, gameOver }) => {
      return (
        <div className="absolute inset-0 z-50 flex flex-col items-center justify-center bg-gray-900 text-white">
          <div className="text-center max-w-md px-6">
            <h1 className="text-6xl font-black text-transparent bg-clip-text bg-gradient-to-b from-yellow-400 to-orange-600 mb-4 filter drop-shadow-lg">
              Neon Survivor
              <span className="block text-2xl text-white mt-2 tracking-widest font-bold">ì›¹ ë²„ì „</span>
            </h1>
            
            {gameOver && (
              <div className="mb-8 p-6 bg-red-900/30 border border-red-500/50 rounded-lg backdrop-blur">
                <h2 className="text-3xl font-bold text-red-400 mb-2">ê²Œì„ ì˜¤ë²„</h2>
                <p className="text-xl text-gray-300">ì²˜ì¹˜í•œ ì : <span className="text-white font-bold">{score}</span></p>
              </div>
            )}

            <div className="space-y-4">
              <button
                onClick={onStart}
                className="w-full py-4 px-8 text-xl font-bold bg-gradient-to-r from-green-500 to-green-700 rounded-full shadow-lg hover:shadow-green-500/50 hover:scale-105 transition-all active:scale-95"
              >
                {gameOver ? 'ë‹¤ì‹œ ì‹œì‘' : 'ì „íˆ¬ ì‹œì‘'}
              </button>
              
              <div className="text-gray-500 text-sm mt-8">
                <p>PC: WASD ì´ë™</p>
                <p>ëª¨ë°”ì¼: í™”ë©´ ë“œë˜ê·¸</p>
                <p className="mt-2 opacity-50">ê³µê²©ì€ ìë™ìœ¼ë¡œ ë°œì‚¬ë©ë‹ˆë‹¤.</p>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // ==========================================
    // MAIN GAME LOGIC
    // ==========================================
    const Game = () => {
      const [gameState, setGameState] = useState('menu');
      const [uiPlayer, setUiPlayer] = useState(null);
      const [kills, setKills] = useState(0);
      const [gameTime, setGameTime] = useState(0); // Frames
      const [upgradeOptions, setUpgradeOptions] = useState([]);
      const [bossWarning, setBossWarning] = useState(false);

      const canvasRef = useRef(null);
      const requestRef = useRef();
      const inputRef = useRef({ x: 0, y: 0 });
      const keysRef = useRef({});
      
      // Game State Refs (Mutable)
      const entitiesRef = useRef({
        player: null,
        enemies: [],
        gems: [],
        projectiles: [],
        damageNumbers: [],
      });

      const gameStatsRef = useRef({
        frameCount: 0,
        kills: 0,
        enemySpawnTimer: 0,
        powerMultiplier: 1,
        cdMultiplier: 1,
        bossSpawned: false,
        currentWaveIndex: 0,
      });

      const initGame = useCallback(() => {
        entitiesRef.current = {
          player: {
            id: 'player',
            x: WORLD_SIZE / 2,
            y: WORLD_SIZE / 2,
            radius: 12,
            color: COLORS.player,
            hp: 100,
            maxHp: 100,
            speed: PLAYER_BASE_SPEED,
            pickupRange: 100,
            weapons: [{ ...BASE_WEAPONS.kunai }],
            level: 1,
            xp: 0,
            nextLevelXp: 5,
            facing: 0,
          },
          enemies: [],
          gems: [],
          projectiles: [],
          damageNumbers: [],
        };

        gameStatsRef.current = {
          frameCount: 0,
          kills: 0,
          enemySpawnTimer: 0,
          powerMultiplier: 1,
          cdMultiplier: 1,
          bossSpawned: false,
          currentWaveIndex: 0,
        };

        setKills(0);
        setGameTime(0);
        setBossWarning(false);
        setUiPlayer(entitiesRef.current.player);
        setGameState('playing');
      }, []);

      const update = () => {
        const state = entitiesRef.current;
        const stats = gameStatsRef.current;
        const player = state.player;

        if (!player || player.hp <= 0) {
          setGameState('gameover');
          return;
        }

        stats.frameCount++;
        setGameTime(stats.frameCount);

        const seconds = stats.frameCount / FPS;

        // --- WAVE LOGIC ---
        let currentWave = WAVES[0];
        for (let i = 0; i < WAVES.length; i++) {
          if (seconds >= WAVES[i].startTime) {
            currentWave = WAVES[i];
            stats.currentWaveIndex = i;
          }
        }

        // Boss Spawning
        if (currentWave.boss && !stats.bossSpawned) {
           spawnBoss(player);
           stats.bossSpawned = true;
           setBossWarning(true);
           setTimeout(() => setBossWarning(false), 3000);
        }

        // --- PLAYER MOVEMENT ---
        let moveX = inputRef.current.x;
        let moveY = inputRef.current.y;

        if (moveX === 0 && moveY === 0) {
            if (keysRef.current['w'] || keysRef.current['ArrowUp']) moveY = -1;
            if (keysRef.current['s'] || keysRef.current['ArrowDown']) moveY = 1;
            if (keysRef.current['a'] || keysRef.current['ArrowLeft']) moveX = -1;
            if (keysRef.current['d'] || keysRef.current['ArrowRight']) moveX = 1;
        }

        if (moveX !== 0 || moveY !== 0) {
          const len = Math.sqrt(moveX * moveX + moveY * moveY);
          moveX /= len;
          moveY /= len;
          player.x += moveX * player.speed;
          player.y += moveY * player.speed;
          player.x = Math.max(0, Math.min(WORLD_SIZE, player.x));
          player.y = Math.max(0, Math.min(WORLD_SIZE, player.y));
          player.facing = Math.atan2(moveY, moveX);
        }

        // --- ENEMY SPAWNING ---
        if (currentWave.enemyTypes.length > 0) {
          stats.enemySpawnTimer++;
          if (stats.enemySpawnTimer > currentWave.spawnRate) {
            stats.enemySpawnTimer = 0;
            
            const angle = Math.random() * Math.PI * 2;
            const dist = 450 + Math.random() * 100; 
            const ex = player.x + Math.cos(angle) * dist;
            const ey = player.y + Math.sin(angle) * dist;
            
            const type = currentWave.enemyTypes[Math.floor(Math.random() * currentWave.enemyTypes.length)];
            
            spawnEnemy(ex, ey, type);
          }
        }

        // --- ENTITY UPDATES ---
        
        // Enemies
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const enemy = state.enemies[i];
          
          const dx = player.x - enemy.x;
          const dy = player.y - enemy.y;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist > 1500 && !enemy.isBoss) {
              state.enemies.splice(i, 1);
              continue;
          }

          enemy.x += (dx / dist) * enemy.speed;
          enemy.y += (dy / dist) * enemy.speed;

          for (let j = i - 1; j >= 0; j--) {
              const other = state.enemies[j];
              if (Math.abs(enemy.x - other.x) < 20 && Math.abs(enemy.y - other.y) < 20) {
                 const d2 = distSq(enemy, other);
                 const minDist = enemy.radius + other.radius;
                 if (d2 < minDist * minDist) {
                      const pushX = enemy.x - other.x;
                      const pushY = enemy.y - other.y;
                      const force = enemy.isBoss ? 0.01 : 0.05;
                      enemy.x += pushX * force;
                      enemy.y += pushY * force;
                 }
              }
          }

          if (enemy.type === 'shooter' && stats.frameCount % 180 === 0 && dist < 400) {
             state.projectiles.push({
                 id: Math.random().toString(),
                 x: enemy.x, y: enemy.y,
                 vx: (dx/dist) * 4, vy: (dy/dist) * 4,
                 radius: 5, color: COLORS.projectileEnemy,
                 damage: 10, duration: 100, pierce: 0, hitIds: [], type: 'bullet'
             });
          }

          if (enemy.isBoss && dist < 200 && stats.frameCount % 300 === 0) {
              enemy.x += (dx/dist) * 50;
              enemy.y += (dy/dist) * 50;
          }

          if (dist < player.radius + enemy.radius) {
            if (stats.frameCount % 30 === 0) {
               player.hp -= Math.max(1, enemy.damage - (i % 2));
               addDamageNumber(player.x, player.y - 20, enemy.damage, 'red');
            }
          }
        }

        // --- WEAPON LOGIC ---
        player.weapons.forEach(w => {
          w.cooldownTimer--;
          const actualCooldown = w.cooldown * stats.cdMultiplier;
          const actualDamage = w.damage * stats.powerMultiplier;

          if (w.cooldownTimer <= 0) {
            if (w.type === 'kunai') {
              const closest = getClosestEnemy(player, w.range);
              if (closest) {
                 const dx = closest.x - player.x;
                 const dy = closest.y - player.y;
                 const dist = Math.sqrt(dx*dx + dy*dy);
                 
                 const count = w.level > 2 ? 2 : 1;
                 for(let c=0; c<count; c++) {
                     state.projectiles.push({
                       id: Math.random().toString(),
                       x: player.x, y: player.y,
                       radius: 4, color: COLORS.projectile,
                       vx: (dx/dist) * (w.projectileSpeed || 10) + (Math.random() - 0.5),
                       vy: (dy/dist) * (w.projectileSpeed || 10) + (Math.random() - 0.5),
                       damage: actualDamage, duration: 60, pierce: 0, hitIds: [], type: 'kunai'
                     });
                 }
                 w.cooldownTimer = actualCooldown;
              }
            }
            else if (w.type === 'brick') {
               state.projectiles.push({
                   id: Math.random().toString(),
                   x: player.x, y: player.y - 20,
                   radius: 8, color: '#a3a3a3',
                   vx: 0, vy: -8, 
                   damage: actualDamage * 2,
                   duration: 100, pierce: 999, hitIds: [], type: 'brick',
                   gravity: 0.4
               });
               w.cooldownTimer = actualCooldown;
            }
            else if (w.type === 'drill') {
                const dx = Math.cos(player.facing);
                const dy = Math.sin(player.facing);
                state.projectiles.push({
                   id: Math.random().toString(),
                   x: player.x, y: player.y,
                   radius: 3, color: '#facc15',
                   vx: dx * (w.projectileSpeed || 15),
                   vy: dy * (w.projectileSpeed || 15),
                   damage: actualDamage,
                   duration: 120, pierce: 999, hitIds: [], type: 'drill'
                });
                w.cooldownTimer = actualCooldown;
            }
            else if (w.type === 'lightning') {
                 const targets = state.enemies.filter(e => distSq(player, e) < (w.range || 500)**2);
                 if (targets.length > 0) {
                     const target = targets[Math.floor(Math.random() * targets.length)];
                     target.hp -= actualDamage;
                     addDamageNumber(target.x, target.y, actualDamage, '#facc15');
                     w.cooldownTimer = actualCooldown;
                 }
            }
            else if (w.type === 'aura') {
                state.enemies.forEach(e => {
                    if (distSq(player, e) < (w.range || 100) ** 2) {
                        e.hp -= actualDamage;
                        if (stats.frameCount % 10 === 0) addDamageNumber(e.x, e.y, actualDamage, 'purple');
                    }
                });
                w.cooldownTimer = actualCooldown;
            }
          }
          // ORB Logic
          if (w.type === 'orb') {
                const orbCount = 2 + w.level;
                const range = w.range || 70;
                const speed = 0.05;
                for(let k=0; k<orbCount; k++) {
                   const angle = (stats.frameCount * speed) + (k * (Math.PI * 2 / orbCount));
                   const ox = player.x + Math.cos(angle) * range;
                   const oy = player.y + Math.sin(angle) * range;
                   state.enemies.forEach(e => {
                      if ((e.x - ox)**2 + (e.y - oy)**2 < (e.radius + 10)**2) {
                         if (stats.frameCount % 15 === 0) {
                           e.hp -= actualDamage;
                           addDamageNumber(e.x, e.y, actualDamage, 'cyan');
                         }
                      }
                   });
                }
          }
        });

        // --- PROJECTILES ---
        for (let i = state.projectiles.length - 1; i >= 0; i--) {
          const p = state.projectiles[i];
          
          if (p.type === 'brick' && p.gravity) {
              p.vy += p.gravity;
          }

          p.x += p.vx;
          p.y += p.vy;
          p.duration--;

          if (p.duration <= 0) {
            state.projectiles.splice(i, 1);
            continue;
          }

          if (p.type === 'bullet') {
             const d2 = distSq(p, player);
             if (d2 < (p.radius + player.radius)**2) {
                 player.hp -= p.damage;
                 addDamageNumber(player.x, player.y, p.damage, 'red');
                 state.projectiles.splice(i, 1);
             }
             continue;
          }

          for (let j = state.enemies.length - 1; j >= 0; j--) {
            const e = state.enemies[j];
            if (p.hitIds.includes(e.id)) continue;

            const d2 = distSq(p, e);
            if (d2 < (p.radius + e.radius)**2) {
               e.hp -= p.damage;
               addDamageNumber(e.x, e.y, p.damage);
               p.hitIds.push(e.id);
               
               if (p.pierce <= 0) {
                 state.projectiles.splice(i, 1);
                 break;
               } else {
                 p.pierce--;
               }
            }
          }
        }

        // --- GEMS ---
        for (let i = state.gems.length - 1; i >= 0; i--) {
          const gem = state.gems[i];
          const d2 = distSq(player, gem);
          
          if (d2 < player.pickupRange ** 2) gem.magnetized = true;

          if (gem.magnetized) {
            const dx = player.x - gem.x;
            const dy = player.y - gem.y;
            const dist = Math.sqrt(d2);
            const speed = 12;
            gem.x += (dx/dist) * speed;
            gem.y += (dy/dist) * speed;

            if (dist < player.radius) {
               if (gem.type === 'xp') {
                  player.xp += gem.value;
               } else if (gem.type === 'health') {
                  player.hp = Math.min(player.maxHp, player.hp + 20);
                  addDamageNumber(player.x, player.y, 20, '#4ade80');
               } else if (gem.type === 'chest') {
                  player.xp += 100; 
                  state.enemies.forEach(e => { if(!e.isBoss) e.hp = 0; });
               }
               state.gems.splice(i, 1);
               checkLevelUp();
            }
          }
        }

        // --- DEATH & LOOT ---
        for (let i = state.enemies.length - 1; i >= 0; i--) {
          const e = state.enemies[i];
          if (e.hp <= 0) {
            stats.kills++;
            setKills(stats.kills);
            
            const rng = Math.random();
            if (e.isBoss) {
                dropGem(e.x, e.y, 0, 'chest');
                stats.bossSpawned = false;
            } else if (rng < 0.01) {
                dropGem(e.x, e.y, 0, 'health');
            } else {
                dropGem(e.x, e.y, e.xpValue, 'xp');
            }
            state.enemies.splice(i, 1);
          }
        }

        // Cleanup damage numbers
        for (let i = state.damageNumbers.length - 1; i >= 0; i--) {
          state.damageNumbers[i].y -= 0.5;
          state.damageNumbers[i].life--;
          if (state.damageNumbers[i].life <= 0) state.damageNumbers.splice(i, 1);
        }

        setUiPlayer({...player}); 
      };

      const spawnEnemy = (x, y, type) => {
          const stats = gameStatsRef.current;
          const hpMult = 1 + (stats.frameCount / 3600); 
          let props = { radius: 10, color: COLORS.enemyBasic, speed: 1.5, hp: 10, xp: 1 };
          switch(type) {
              case 'fast': props = { radius: 8, color: COLORS.enemyFast, speed: 2.8, hp: 5, xp: 2 }; break;
              case 'tank': props = { radius: 18, color: COLORS.enemyTank, speed: 0.8, hp: 40, xp: 5 }; break;
              case 'swarm': props = { radius: 6, color: COLORS.enemySwarm, speed: 2.0, hp: 2, xp: 1 }; break;
              case 'shooter': props = { radius: 12, color: COLORS.enemyShooter, speed: 1.2, hp: 15, xp: 3 }; break;
          }
          entitiesRef.current.enemies.push({
              id: Math.random().toString(36).substr(2, 9),
              x, y,
              radius: props.radius,
              color: props.color,
              hp: props.hp * hpMult,
              maxHp: props.hp * hpMult,
              speed: props.speed,
              damage: 5 + Math.floor(stats.frameCount / 1000),
              xpValue: props.xp,
              type: type,
              isBoss: false
          });
      };

      const spawnBoss = (player) => {
          const angle = Math.random() * Math.PI * 2;
          const dist = 500;
          entitiesRef.current.enemies.push({
              id: 'BOSS',
              x: player.x + Math.cos(angle) * dist,
              y: player.y + Math.sin(angle) * dist,
              radius: 40,
              color: COLORS.enemyBoss,
              hp: 5000 * (1 + gameStatsRef.current.frameCount/10000),
              maxHp: 5000 * (1 + gameStatsRef.current.frameCount/10000),
              speed: 1.5,
              damage: 20,
              xpValue: 100,
              type: 'boss',
              isBoss: true
          });
      };

      const dropGem = (x, y, val, type) => {
          let color = COLORS.gem1;
          if (val > 2) color = COLORS.gem10;
          if (type === 'health') color = COLORS.gemHealth;
          if (type === 'chest') color = COLORS.gemChest;
          entitiesRef.current.gems.push({
              id: Math.random().toString(),
              x, y, radius: type === 'chest' ? 8 : 4,
              color, value: val, magnetized: false, type
          });
      };

      const getClosestEnemy = (player, range = 600) => {
          let closest = null;
          let closestDist = Infinity;
          entitiesRef.current.enemies.forEach(e => {
            const d = distSq(player, e);
            if (d < range*range && d < closestDist) {
              closestDist = d;
              closest = e;
            }
          });
          return closest;
      };

      const addDamageNumber = (x, y, dmg, color = COLORS.textDamage) => {
        entitiesRef.current.damageNumbers.push({
          id: Math.random().toString(),
          x, y, value: Math.floor(dmg), life: 30, color
        });
      };

      const checkLevelUp = () => {
        const p = entitiesRef.current.player;
        if (!p) return;
        if (p.xp >= p.nextLevelXp) {
          p.level++;
          p.xp -= p.nextLevelXp;
          p.nextLevelXp = Math.floor(p.nextLevelXp * 1.4);
          const options = [];
          for(let i=0; i<3; i++) {
            options.push(UPGRADES_POOL[Math.floor(Math.random() * UPGRADES_POOL.length)]);
          }
          setUpgradeOptions(options);
          setGameState('levelup');
        }
      };

      const applyUpgrade = (opt) => {
         const p = entitiesRef.current.player;
         const stats = gameStatsRef.current;
         if(!p) return;
         if (opt.id === 'heal_potion') {
           p.hp = Math.min(p.maxHp, p.hp + (p.maxHp * 0.3));
         } else if (opt.type === 'stat') {
            if (opt.statType === 'speed') p.speed *= 1.1;
            if (opt.statType === 'maxHp') { p.maxHp *= 1.2; p.hp += 20; }
            if (opt.statType === 'pickupRange') p.pickupRange *= 1.25;
            if (opt.statType === 'cooldown') stats.cdMultiplier *= 0.9;
            if (opt.statType === 'power') stats.powerMultiplier *= 1.15;
         } else if (opt.type === 'weapon') {
            const existing = p.weapons.find(w => w.type === opt.weaponType);
            if (existing) {
              existing.level++;
              existing.damage *= 1.2;
              existing.cooldown *= 0.9;
            } else {
              if (opt.weaponType && BASE_WEAPONS[opt.weaponType]) {
                 p.weapons.push({ ...BASE_WEAPONS[opt.weaponType] });
              }
            }
         }
         setGameState('playing');
      };

      const draw = (ctx) => {
        const { player, enemies, gems, projectiles, damageNumbers } = entitiesRef.current;
        if (!player) return;

        const canvas = ctx.canvas;
        const width = canvas.width;
        const height = canvas.height;
        const camX = player.x - width / 2;
        const camY = player.y - height / 2;

        // BG
        ctx.fillStyle = '#1f2937';
        ctx.fillRect(0, 0, width, height);

        // Grid
        ctx.strokeStyle = '#374151';
        ctx.lineWidth = 2;
        const gridSize = 100;
        const startX = Math.floor(camX / gridSize) * gridSize;
        const startY = Math.floor(camY / gridSize) * gridSize;
        ctx.beginPath();
        for (let x = startX; x < camX + width + gridSize; x += gridSize) {
           ctx.moveTo(x - camX, 0);
           ctx.lineTo(x - camX, height);
        }
        for (let y = startY; y < camY + height + gridSize; y += gridSize) {
          ctx.moveTo(0, y - camY);
          ctx.lineTo(width, y - camY);
        }
        ctx.stroke();

        const drawCircle = (x, y, r, color, stroke = true) => {
           if (x < -50 || x > width + 50 || y < -50 || y > height + 50) return;
           ctx.beginPath();
           ctx.fillStyle = color;
           ctx.arc(x, y, r, 0, Math.PI * 2);
           ctx.fill();
           if(stroke) {
             ctx.strokeStyle = 'rgba(0,0,0,0.4)';
             ctx.lineWidth = 2;
             ctx.stroke();
           }
        };

        gems.forEach(g => {
           const cx = g.x - camX;
           const cy = g.y - camY;
           if (g.type === 'chest') {
               ctx.fillStyle = g.color;
               ctx.fillRect(cx - 6, cy - 6, 12, 12);
               ctx.strokeStyle = '#fff';
               ctx.strokeRect(cx - 6, cy - 6, 12, 12);
           } else {
               ctx.save();
               ctx.translate(cx, cy);
               ctx.rotate(gameStatsRef.current.frameCount * 0.1);
               ctx.fillStyle = g.color;
               ctx.beginPath();
               ctx.moveTo(0, -5);
               ctx.lineTo(4, 0);
               ctx.lineTo(0, 5);
               ctx.lineTo(-4, 0);
               ctx.fill();
               ctx.restore();
           }
        });

        enemies.forEach(e => {
            const cx = e.x - camX;
            const cy = e.y - camY;
            drawCircle(cx, cy, e.radius, e.color);
            if (e.isBoss) {
                 ctx.fillStyle = 'black';
                 ctx.fillRect(cx - 30, cy - e.radius - 15, 60, 8);
                 ctx.fillStyle = 'red';
                 ctx.fillRect(cx - 30, cy - e.radius - 15, 60 * (e.hp/e.maxHp), 8);
            }
        });

        projectiles.forEach(p => {
            const cx = p.x - camX;
            const cy = p.y - camY;
            if (p.type === 'brick') {
                 ctx.fillStyle = '#a3a3a3';
                 ctx.fillRect(cx-8, cy-4, 16, 8);
            } else if (p.type === 'drill') {
                 ctx.save();
                 ctx.translate(cx, cy);
                 ctx.rotate(Math.atan2(p.vy, p.vx));
                 ctx.fillStyle = '#facc15';
                 ctx.beginPath();
                 ctx.moveTo(10, 0);
                 ctx.lineTo(-5, 5);
                 ctx.lineTo(-5, -5);
                 ctx.fill();
                 ctx.restore();
            } else {
                 drawCircle(cx, cy, p.radius, p.color, false);
            }
        });

        ctx.save();
        ctx.translate(player.x - camX, player.y - camY);

        const aura = player.weapons.find(w => w.type === 'aura');
        if (aura) {
           ctx.fillStyle = 'rgba(50, 255, 50, 0.1)';
           ctx.beginPath();
           ctx.arc(0, 0, aura.range || 100, 0, Math.PI*2);
           ctx.fill();
           ctx.strokeStyle = 'rgba(50, 255, 50, 0.4)';
           ctx.lineWidth = 1;
           ctx.stroke();
        }
        const orb = player.weapons.find(w => w.type === 'orb');
        if (orb) {
           const count = 2 + orb.level;
           const range = orb.range || 70;
           const angleOffset = gameStatsRef.current.frameCount * 0.05;
           ctx.fillStyle = '#0ea5e9';
           for(let k=0; k<count; k++) {
              const a = angleOffset + (k * Math.PI * 2 / count);
              const ox = Math.cos(a) * range;
              const oy = Math.sin(a) * range;
              ctx.beginPath();
              ctx.arc(ox, oy, 8, 0, Math.PI*2);
              ctx.fill();
              ctx.strokeStyle = 'white';
              ctx.stroke();
           }
        }

        ctx.fillStyle = player.color;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = 'white';
        ctx.lineWidth = 3;
        ctx.stroke();

        const hpW = 40;
        ctx.fillStyle = '#991b1b';
        ctx.fillRect(-hpW/2, -player.radius - 12, hpW, 6);
        ctx.fillStyle = '#22c55e';
        ctx.fillRect(-hpW/2, -player.radius - 12, hpW * (player.hp/player.maxHp), 6);
        ctx.restore();

        ctx.font = 'bold 14px sans-serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = 'black';
        ctx.lineWidth = 2;
        damageNumbers.forEach(dn => {
          const cx = dn.x - camX;
          const cy = dn.y - camY;
          ctx.fillStyle = dn.color;
          ctx.globalAlpha = dn.life / 30;
          ctx.strokeText(Math.floor(dn.value).toString(), cx, cy);
          ctx.fillText(Math.floor(dn.value).toString(), cx, cy);
          ctx.globalAlpha = 1;
        });
      };

      const loop = useCallback(() => {
        if (gameState === 'playing') update();
        if (canvasRef.current) {
          const ctx = canvasRef.current.getContext('2d');
          if (ctx) draw(ctx);
        }
        requestRef.current = requestAnimationFrame(loop);
      }, [gameState]);

      useEffect(() => {
        requestRef.current = requestAnimationFrame(loop);
        return () => { if (requestRef.current) cancelAnimationFrame(requestRef.current); };
      }, [loop]);

      useEffect(() => {
        const onKeyDown = (e) => keysRef.current[e.key] = true;
        const onKeyUp = (e) => keysRef.current[e.key] = false;
        window.addEventListener('keydown', onKeyDown);
        window.addEventListener('keyup', onKeyUp);
        const handleResize = () => {
           if (canvasRef.current) {
             canvasRef.current.width = window.innerWidth;
             canvasRef.current.height = window.innerHeight;
           }
        };
        window.addEventListener('resize', handleResize);
        handleResize();
        return () => {
          window.removeEventListener('keydown', onKeyDown);
          window.removeEventListener('keyup', onKeyUp);
          window.removeEventListener('resize', handleResize);
        };
      }, []);

      return (
        <div className="relative w-screen h-screen overflow-hidden bg-gray-900 text-white font-sans select-none">
          <canvas ref={canvasRef} className="block" />
          
          {gameState === 'playing' && uiPlayer && (
            <React.Fragment>
              <HUD player={uiPlayer} time={gameTime} kills={kills} />
              <VirtualJoystick onMove={(x, y) => inputRef.current = { x, y }} />
            </React.Fragment>
          )}

          {bossWarning && (
            <div className="absolute inset-0 flex items-center justify-center pointer-events-none z-40">
               <div className="bg-red-600/80 text-white text-6xl font-black py-4 px-20 animate-pulse transform -rotate-3 border-y-4 border-black shadow-2xl">
                  ë³´ìŠ¤ ì¶œí˜„!
               </div>
            </div>
          )}

          {(gameState === 'menu' || gameState === 'gameover') && (
            <MainMenu 
              onStart={initGame} 
              gameOver={gameState === 'gameover'} 
              score={kills}
            />
          )}

          {gameState === 'levelup' && (
            <UpgradeModal options={upgradeOptions} onSelect={applyUpgrade} />
          )}
        </div>
      );
    };

    const App = () => {
      return (
        <Game />
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>